# Object-oriented programming in C++

## Inheritance

Inheritance is a mechanism that allows you to create derived classes by extending existing ones.
```
struct Person {
	string name () const { return name_; }
	int age () const { return age_; }
private :
	string name_ ;
	int age_ ;
};

struct Student : public Person {
	string university () const { return uni_; }
private :
	string uni_ ;
};
```

When creating an object of a child class, the constructor of the parent class is called first, then the constructor of the child class. When deleting an object of a child class, the destructor of the parent class is called first.

The following **casts** are defined for derived classes:
```
Student s ( " Alex " , 21 , " Oxford " );
Person & l = s ; // Student & -> Person &
Person * r = & s ; // Student * -> Person *
```
Therefore, objects of the child class can be assigned to objects of the parent class:
```
Student s ( " Alex " , 21 , " Oxford " );
Person p = s ; // Person("Alex", 21);
```
Only the fields of the parent class are copied.

## Access Modifiers

- **Public** — access is open to all other classes who see the definition of this class.
- **Protected** — access is open to classes derived from this. That is, derived classes get free access to such properties or methods. All other classes do not have such access.
- **Private** — access is open to the class itself (i.e., member functions of this class) and friends of this class - both functions and classes. However, derived classes do not get access to this data at all. And all other classes do not have such access.

Public and protected methods of the parent class can be called for objects of the descendant class. The descendant class does not have access to the private members of the parent class. The protected modifier is used to determine the private members of the class available to heirs.

## Function overloading

Unlike C, in C++, you can define several functions with the same name but different parameters.
```
double square (double d) { return d * d; }
int square (int i) { return i * i; }
```
When calling a function by name, the compiler will find the most appropriate function.

## Methods overloading

Overloading is also available for methods. To overload a method from the parent class, specify it in the child class:
```
struct File {
	void write(char const * s);
	...
};

struct FormattedFile : File {
	void write(int i);
	void write(double d);
	using File::write;
	...
};
```

## Other info

If the structure or class has no constructors, then the constructor without parameters, the **default constructor**, is generated by the compiler. If at least 1 constructor is defined by the programmer, then there will be no default constructor generation.

"If something looks like a function declaration, then it is a function declaration."
```
struct Point {
	explicit Point ( double x = 0 , double y = 0)
		: x(x), y(y) {}
	double x ;
	double y ;
};
<...>
	Point p1; // definition of variable
	Point p2(); // function declaration
	double k = 5.1;
	Point p3(int(k)); // function declaration
	Point p4((int)k); // definition of variable
```
